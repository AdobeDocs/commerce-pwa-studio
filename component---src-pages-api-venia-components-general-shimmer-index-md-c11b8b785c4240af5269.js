"use strict";(self.webpackChunkcommerce_pwa_studio=self.webpackChunkcommerce_pwa_studio||[]).push([[9658],{45796:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return p},default:function(){return u}});var o=t(87462),m=t(63366),a=(t(15007),t(64983)),s=t(99536),r=t(78350),i=["components"],p={},l={_frontmatter:p},d=s.Z;function u(e){var n=e.components,t=(0,m.Z)(e,i);return(0,a.mdx)(d,(0,o.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"shimmer"},"Shimmer"),(0,a.mdx)("p",null,"The Shimmer component is a loading indicator that takes the shape of the component being loaded.\nInstead of blocking the entire page like a traditional full-screen loader, Shimmer loaders are component-shape specific to show users previews of what's loading on the page."),(0,a.mdx)("p",null,"These previews improves the perceived performance of the app and prevents CLS (Content Layout Shift).\nThe Shimmer component eliminates most of the CLS on a page, which helps improve Google Lighthouse scores."),(0,a.mdx)(r.Z,{mdxType:"Shimmer"}),(0,a.mdx)("h2",{id:"shimmer-for-components"},"Shimmer for Components"),(0,a.mdx)("p",null,"When loading data, previously we would return ",(0,a.mdx)("inlineCode",{parentName:"p"},"null")," (or a full-screen loader) instead of the actual component. We can now return a\n",(0,a.mdx)("em",{parentName:"p"},(0,a.mdx)("strong",{parentName:"em"},"shimmer"))," version of the component, which will take up the same space without relying on data."),(0,a.mdx)("p",null,"Direct use of the ",(0,a.mdx)("inlineCode",{parentName:"p"},"Shimmer")," component within ",(0,a.mdx)("em",{parentName:"p"},"normal")," components should be avoided when possible. If the shimmer is replacing a component\nthat is imported, a ",(0,a.mdx)("inlineCode",{parentName:"p"},".shimmer.js")," file should be created for that imported component in its folder and exported in its ",(0,a.mdx)("inlineCode",{parentName:"p"},"index.js"),"."),(0,a.mdx)("h3",{id:"example"},"Example"),(0,a.mdx)("p",null,"There are 4 critical files for creating a Shimmer component:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Main.js")," - the main component that has the loading status and would usually return null for the component while loading"),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"SubComponent/index.js")," - Previously would only export the main component. Must now export named variable for shimmer component"),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"SubComponent/subComponent")," - Same SubComponent as usual"),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"SubComponent/subComponent.shimmer.js")," - ",(0,a.mdx)("inlineCode",{parentName:"li"},".shimmer.js")," extension is used for easily identifying that it's a shimmer and\nthe component it's attached to. It can contain complex arrangement of base Shimmer elements, or include other subcomponents Shimmers.")),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"Main.js")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport SubComponent, { SubComponentShimmer } from '../path/to/SubComponent';\n// ....\nexport default () => {\n    const { data, isLoading } = fetchData();\n\n    if (isLoading) {\n        return (\n          <SubComponentShimmer />\n        );\n    }\n\n    if (!data) {\n        return 'No data';\n    }\n\n    return (\n        <SubComponent someValue={data} />\n    );\n};\n// ....\n")),(0,a.mdx)("hr",null),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"../path/to/SubComponent/index.js")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-jsx"},"export { default } from './subComponent.js';\n// Export named shimmer component\nexport { default as SubComponentShimmer } from './subComponent.shimmer.js';\n")),(0,a.mdx)("hr",null),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"../path/to/SubComponent/subComponent.js")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport { shape, string } from 'prop-types';\nimport { useStyle } from '../../path/to/classify';\nimport defaultClasses from './subComponent.css';\nconst SubComponent = (props) => {\n    const classes = useStyle(defaultClasses, props.classes);\n    const { someValue } = props;\n\n    return (\n        <div className={classes.root}>\n          <div className={classes.item}>{someValue}</div>\n        </div>\n    );\n};\nSubComponent.defaultProps = {\n    classes: {}\n};\nSubComponent.propTypes = {\n    classes: shape({\n      root: string,\n      item: string\n    })\n}\nexport default SubComponent;\n")),(0,a.mdx)("hr",null),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"../path/to/SubComponent/subComponent.shimmer.js")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport { useStyle } from '../../path/to/classify';\nimport Shimmer from '../path/to/base/Shimmer';\nimport defaultClasses from './subComponent.css'; // Load same classes as real SubComponent\nconst SubComponentShimmer = (props) => {\n    // Important to still merge-in prop classes for extensibility/targetability\n    const classes = useStyle(defaultClasses, props.classes);\n\n    return (\n      <div className={classes.root}>\n        <Shimmer className={classes.item} />\n      </div>\n    );\n};\nSubComponentShimmer.defaultProps = {\n  classes: {}\n};\nSubComponentShimmer.propTypes = {\n  classes: shape({\n    root: string,\n    item: string\n  })\n}\nexport default SubComponentShimmer;\n")),(0,a.mdx)("h2",{id:"adjusting-existing-shimmers"},"Adjusting existing Shimmers"),(0,a.mdx)("p",null,"When you make layout changes to a Shimmer's parent component, you should also adjust the Shimmer component to match.\nIn this example, we'll add a custom attribute shimmer to the detail section of the product page."),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"local-intercept.js")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-jsx"},"const { Targetables } = require('@magento/pwa-buildpack');\nconst targetables = Targetables.using(targets);\nconst productShimmerComponent = targetables.reactComponent(\n    '@magento/venia-ui/lib/RootComponents/Product/product.shimmer'\n);\n\n/**\n * As a best practice, you should create a separate Shimmer file for the new attribute and import it into the\n * productShimmerComponent. But for simplicity, we'll inline the jsx as shown here.\n */\nproductShimmerComponent.appendJSX(\n    'section className={classes.details}'\n    `<div className={classes.detailsTitle}>\n        <Shimmer width=\"100%\" height={1} />\n     </div>\n     <Shimmer width=\"100%\" height={1} />`\n);\n")),(0,a.mdx)("h2",{id:"accessibility"},"Accessibility"),(0,a.mdx)("p",null,"To maintain accessibility for screen readers, we can pass ",(0,a.mdx)("inlineCode",{parentName:"p"},'aria-live="polite" aria-busy="true"')," to the Shimmer component (or an\nelement that wraps the Shimmer(s) in a more complex instance)."),(0,a.mdx)("p",null,"It's important to then add ",(0,a.mdx)("inlineCode",{parentName:"p"},'aria-live="polite" aria-busy="false"')," to the ",(0,a.mdx)("em",{parentName:"p"},"normal")," component that replaces the shimmer."),(0,a.mdx)("h3",{id:"example-1"},"Example"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-jsx"},"// ....\nimport Shimmer from '../path/to/base/Shimmer';\n// ....\nexport default () => {\n  // ....\n  return (\n    <Shimmer />\n  );\n};\n")))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-api-venia-components-general-shimmer-index-md-c11b8b785c4240af5269.js.map
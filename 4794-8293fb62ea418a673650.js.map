{"version":3,"file":"4794-8293fb62ea418a673650.js","mappings":"kLAAW,EAQAA,EAKAC,EAMAC,EAIA,E,iCAtBX,SAAWC,GACPA,EAAkB,KAAI,OACtBA,EAAmB,MAAI,QACvBA,EAAiB,IAAI,MACrBA,EAAoB,OAAI,SACxBA,EAAiB,IAAI,KACxB,CAND,CAMG,IAAgB,EAAc,CAAC,IAElC,SAAWH,GACPA,EAAsB,UAAI,YAC1BA,EAAqB,SAAI,UAC5B,CAHD,CAGGA,IAAeA,EAAa,CAAC,IAEhC,SAAWC,GACPA,EAA+B,oBAAI,sBACnCA,EAA6B,kBAAI,oBACjCA,EAAuB,YAAI,aAC9B,CAJD,CAIGA,IAAcA,EAAY,CAAC,IAE9B,SAAWC,GACPA,EAAgC,eAAI,gBACvC,CAFD,CAEGA,IAAoBA,EAAkB,CAAC,IAE1C,SAAWE,GACPA,EAAyB,QAAI,SAChC,CAFD,CAEG,IAAoB,EAAkB,CAAC,IC1B1C,MAAMC,EAA2B,CAC7B,QAAS,KACT,SAAU,OAERC,EAAY,oCACZC,EAAsB,CAAC,QAAS,SCF/B,MAAMC,EAAiB,EAAGC,OAAMC,UAASC,YAAa,CACzDF,OACAC,UACAC,UCNJ,IAAIC,EAAK,EAIT,YAAuBA,ECJvB,MACMC,EAAqBC,GAAYA,EAAUA,EAAQC,MAD9B,KAC0D,GAgBxEC,EAAe,CAACC,EAASH,EAASI,KAC3C,MAAMC,EAAWN,EAAkBC,GAUnC,OATAK,EAASC,QAAO,CAACC,EAAaC,EAAKC,UACC,IAArBF,EAAYC,KACnBD,EAAYC,GAAO,CAAC,GAEpBC,IAAQJ,EAASK,OAAS,IAC1BH,EAAYC,GAAOJ,GAEhBG,EAAYC,KACpBL,GACIA,CAAO,EAUL,EAAmB,CAACQ,EAASC,KACtC,MAAMC,EAAmB,CAAC,EAa1B,OAZAC,OAAOC,KAAKJ,GAASK,SAASR,IAC1B,MAAMJ,EAAQO,EAAQH,GAChBR,EAvCQ,EAACQ,EAAKI,KACxB,MAAMP,EAAWN,EAAkBa,GAAU,IAE7C,OADAP,EAASY,KAAKT,GAHQ,CAACH,GAAaA,EAASa,KAFtB,KAMhBC,CAAkBd,EAAS,EAoCde,CAAcZ,EAAKI,GACd,iBAAVR,GAEPU,OAAOO,OAAOR,EAAkB,EAAiBT,EAAOJ,IAEvC,mBAAVI,IAEPS,EAAiBb,GAAWI,EAChC,IAEGS,CAAgB,ECrC3B,OAAgBS,EAAYC,EAAMC,EAAgBC,EAAmBC,KACjE,MAAM,UAAEC,EAAS,MAAEC,EAAK,OAAEC,EAAM,iBAAEC,EAAgB,mBAAEC,GAAwBR,EAC5E,IAAIS,GAAY,EAChBN,EAAI,GAAGC,6BACP,MAAMM,EAAqBC,GAChB,IAAIC,KAWP,IAAIC,EAVJV,EAAI,GAAGC,cAAsBO,YAW7B,IACQL,EAAOQ,SACPD,GAAgB,EAExB,CACA,MAAOE,GACHF,GAAgB,CACpB,CAIA,GAHIA,GACAX,IAEAO,EAAW,CACX,MAAMO,EAAQ,IAAIC,MAAM,kBAAkBN,wCAE1C,MADAK,EAAME,KAAOtD,EAAUuD,oBACjBH,CACV,CACA,OAAO,IAAII,SAAQ,CAACC,EAASC,KACzB,MAAM/C,EAAKgD,IACLC,EAAsBC,IACxB,GAAIA,EAAMC,SAAWpB,GACjBmB,EAAME,KAAKC,SAAW,SACtBH,EAAME,KAAKpD,KAAOA,EAClB,OAEJ,GAA2B,MAAvBiC,GACAiB,EAAMI,SAAWrB,EAEjB,YADAL,EAAI,GAAGC,kCAA0CqB,EAAMI,8CAA8CrB,KAGzG,MAAMsB,EAAeL,EAAME,KAC3BxB,EAAI,GAAGC,eAAuBO,aAC9BN,EAAM0B,oBAAoB,UAAyBP,GACnD,IAAIQ,EAAcF,EAAaE,YAC3BF,EAAaG,qBACbD,EHvDQ,CAACE,IAC7B,MAAMC,EAAoB,IAAIlB,MAG9B,OADA1B,OAAOC,KAAK0C,GAAKzC,SAASR,GAASkD,EAAkBlD,GAAOiD,EAAIjD,KACzDkD,CAAiB,EGmDUC,CAAiBJ,KAElCF,EAAaO,aAAe1E,EAAW2E,UAAYjB,EAAUC,GAAQU,EAAY,EAEtF3B,EAAMkC,iBAAiB,UAAyBf,GAChD,MAAMgB,EAAc,CAChBZ,OAAQ,OACRrD,KACAoC,aACAC,QAEJN,EAAOmC,YAAYD,EAAajC,EAAiB,GACnD,EAIJjB,EAAmBW,EAAelB,QAAO,CAAC2D,EAAKtE,KACjDsE,EAAItE,GAAQsC,EAAkBtC,GACvBsE,IACR,CAAC,GAIJ,OADAnD,OAAOO,OAAOC,ED5BgB,CAACT,IAC/B,MAAMF,EAAU,CAAC,EACjB,IAAK,MAAMX,KAAWa,EAClBX,EAAaS,EAASX,EAASa,EAAiBb,IAEpD,OAAOW,CAAO,ECuBYuD,CAAmBrD,IACtC,KACHmB,GAAY,CAAI,CAEvB,ECvFD,GAAgBmC,EAAmBC,EAAatC,EAAkBuC,EAAY3C,KAC1E,MAAM,QAAE4C,EAAO,UAAEC,GAAcF,EAC/B,IAAIG,EACAC,EAKJ,MAAMnD,EAAa,CAAC,EACpB,OAAQ0B,IACJ,GAAoB,MAAhBoB,GAAuBpB,EAAMI,SAAWgB,EAExC,YADA1C,EAAI,wDAAwDsB,EAAMI,8CAA8CgB,KAGpH1C,EAAI,oCACJ,MAAMH,EAAO,CACTI,UAAW,SACXC,MAAO8C,OACP7C,OAAQmB,EAAMC,OACdnB,iBAAkBA,EAClBC,mBAAoBqC,GAIpBI,GACAA,IAEJA,EC1BR,EAAgBjD,EAAM4C,EAAmBzC,KACrC,MAAM,UAAEC,EAAS,MAAEC,EAAK,OAAEC,EAAM,iBAAEC,EAAgB,mBAAEC,GAAwBR,EAC5E,IAAIS,GAAY,EAChB,MAAMe,EAAsBC,IACxB,GAAIA,EAAMC,SAAWpB,GAAUmB,EAAME,KAAKC,SAAW,OACjD,OAEJ,GAA2B,MAAvBpB,GAA8BiB,EAAMI,SAAWrB,EAE/C,YADAL,EAAI,GAAGC,kCAA0CqB,EAAMI,8CAA8CrB,KAGzG,MAAMgC,EAAcf,EAAME,MACpB,WAAEhB,EAAU,KAAEC,EAAI,GAAErC,GAAOiE,EACjCrC,EAAI,GAAGC,eAAuBO,YAC9B,MAAMyC,EAAwBf,GAClBL,IAEJ,GADA7B,EAAI,GAAGC,cAAsBO,aACzBF,EAOA,YADAN,EAAI,GAAGC,qBAA6BO,yCAGxC,MAAMtC,EAAU,CACZuD,OAAQ,QACRrD,KACA8D,aACAL,eAEAK,IAAe1E,EAAW0F,UAC1BrB,aAAuBf,QACvB5C,EAAQ2D,YAAc7D,EAAe6D,GACrC3D,EAAQ4D,oBAAqB,GAEjC,IACI3B,EAAOmC,YAAYpE,EAASkC,EAChC,CACA,MAAO+C,GAGH,GAAIA,EAAIlF,OAASP,EAAgB0F,eAAgB,CAC7C,MAAMC,EAAoB,CACtB5B,OAAQ,QACRrD,KACA8D,WAAY1E,EAAW0F,SACvBrB,YAAa7D,EAAemF,GAC5BrB,oBAAoB,GAExB3B,EAAOmC,YAAYe,EAAmBjD,EAC1C,CACA,MAAM+C,CACV,GAGR,IAAIlC,SAASC,GAAYA,EAAQuB,EAAkBjC,GAAY8C,MAAMb,EAAmBhC,MAAQ8C,KAAKN,EAAqBzF,EAAW2E,WAAYc,EAAqBzF,EAAW0F,UAAU,EAG/L,OADAhD,EAAMkC,iBAAiB,UAAyBf,GACzC,KACHf,GAAY,EACZJ,EAAM0B,oBAAoB,UAAyBP,EAAmB,CAE7E,EDtC6B,CAAoBxB,EAAM4C,EAAmBzC,GACnE6C,EAAUC,GAGNC,GACAA,EAAoBzD,SAASkE,WAClB5D,EAAW4D,EAAmB,IAG7CT,EAAsBzB,EAAME,KAAKiC,YACjC,MAAMC,EAAoB,EAAkB9D,EAAYC,EAAMkD,EAAqBH,EAAS5C,GAE5F,OADA6C,EAAUa,GACH9D,CAAU,CAExB,EEpCD,ICGA,EAAgB+D,IACZ,IAAI,OAAEC,EAAM,QAAE3E,EAAU,CAAC,EAAC,YAAEyD,EAAW,QAAEmB,EAAO,MAAEC,GAAQ,GAAUH,EACpE,MAAM3D,ECfV,CAAgB8D,GAIL,IAAIrD,KACHqD,GACAC,QAAQ/D,IAAI,cAAeS,EAC/B,EDQQ,CAAaqD,GACnBnB,EEhBV,EAAgB1C,EAAWD,KACvB,MAAMgE,EAAY,GAClB,IAAI1D,GAAY,EAChB,MAAO,CACHsC,QAAQ/B,GACCP,IACDA,GAAY,EACZN,EAAI,GAAGC,4BACP+D,EAAU1E,SAAS2E,IACfA,EAASpD,EAAM,IAG3B,EACAgC,UAAUoB,GACN3D,EAAY2D,IAAaD,EAAUzE,KAAK0E,EAC5C,EAEP,EFDsB,CAAiB,SAAUjE,IACxC,UAAE6C,EAAS,QAAED,GAAYD,EAC1BD,IGjBT,CAAgBkB,IACZ,IAAKA,EAAOM,MAAQN,EAAOO,OAAQ,CAC/B,MAAMtD,EAAQ,IAAIC,MAAM,oDAExB,MADAD,EAAME,KAAOtD,EAAU2G,YACjBvD,CACV,CACH,EHYOwD,CAA6BT,GAC7BlB,ERXR,CAAgBwB,IACZ,GAAIA,GAAOnG,EAAoBuG,MAAMC,GAAWL,EAAIM,WAAWD,KAI3D,MAAO,OAKX,MAAME,EAAWC,SAASD,SACpBE,EAAc7G,EAAU8G,KAAKV,GACnC,IAAIW,EACAC,EACAC,EAiBJ,OAhBIJ,GAGAE,EAAWF,EAAY,GAAKA,EAAY,GAAKF,EAASI,SACtDC,EAAWH,EAAY,GACvBI,EAAOJ,EAAY,KAInBE,EAAWJ,EAASI,SACpBC,EAAWL,EAASK,SACpBC,EAAON,EAASM,MAKb,GAAGF,MAAaC,IADJC,GAAQA,IAASlH,EAAyBgH,GAAY,IAAIE,IAAS,IAEzF,EQrBqBC,CAAiBpB,EAAOM,MAK1C,MAAM9D,EAAmC,SAAhBsC,EAAyB,IAAMA,EAClDD,EAAoB,EAAiBxD,GACrCgG,EIvBV,EAAgBjF,EAAKyC,EAAmBC,EAAatC,IACzCkB,IAKJ,IAAKA,EAAMC,OACP,OAEJ,GAAoB,MAAhBmB,GAAuBpB,EAAMI,SAAWgB,EAExC,YADA1C,EAAI,wDAAwDsB,EAAMI,8CAA8CgB,KAGpH1C,EAAI,6DACJ,MAAMkF,EAAgB,CAClBzD,OAAQ,SACRgC,YAAarE,OAAOC,KAAKoD,IAE7BnB,EAAMC,OAAOe,YAAY4C,EAAe9E,EAAiB,EJKpC+E,CAAwBnF,EAAKyC,EAAmBC,EAAatC,GAChFgF,EAAmBC,EAAwB5C,EAAmBC,EAAatC,EAAkBuC,EAAY3C,GACzGsF,EAAU,IAAIrE,SAAQ,CAACC,EAASC,KAClC,MAAMoE,EKzBd,EAAgB1B,EAASI,KACrB,IAAIuB,EAQJ,YAPgBC,IAAZ5B,IACA2B,EAAYxC,OAAO0C,YAAW,KAC1B,MAAM7E,EAAQ,IAAIC,MAAM,8BAA8B+C,OACtDhD,EAAME,KAAOtD,EAAUkI,kBACvB1B,EAASpD,EAAM,GAChBgD,IAEA,KACH+B,aAAaJ,EAAU,CAE9B,ELaqC,CAAuB3B,EAASjB,GACxDiD,EAAiBvE,IACnB,GAAIA,EAAMC,SAAWqC,EAAOkC,eAAkBxE,EAAME,KAGpD,GAAIF,EAAME,KAAKC,SAAW,MAI1B,GAAIH,EAAME,KAAKC,SAAW,WAA1B,CACI,MAAM7B,EAAawF,EAAiB9D,GAChC1B,IACA2F,IACArE,EAAQtB,GAGhB,MAVIqF,EAAiB3D,EAUrB,EAEJ0B,OAAOZ,iBAAiB,UAAyByD,GACjD7F,EAAI,8BDvCZ,EAAgB4D,EAAQjB,KACpB,MAAM,QAAEC,EAAO,UAAEC,GAAcF,EACzBoD,EAA6BC,aAAY,KACtCpC,EAAOqC,cACRC,cAAcH,GACdnD,IACJ,GAhB6B,KAkBjCC,GAAU,KACNqD,cAAcH,EAA2B,GAEhD,EC6BOI,CAAqBvC,EAAQjB,GAC7BE,GAAWhC,IACPmC,OAAOpB,oBAAoB,UAAyBiE,GAChDhF,GACAM,EAAON,EACX,GACF,IAEN,MAAO,CACHyE,UACA1C,UAEIA,GACJ,EAEP,EM/CD,I,iCCwIA,MArIcwD,IAA4F,IAA3F,IAAElC,EAAG,OAAEmC,EAAS,0DAAyD,SAAE5B,GAAU2B,EAClG,MAAMxC,GAAS0C,EAAAA,EAAAA,QAAO,OAEhB,IAAEC,EAAG,aAAEC,IAAiBC,EAAAA,EAAAA,YAAWC,EAAAA,IACzC,IAAIC,EACJ,MAAM,EAACC,EAAM,EAACC,IAAYC,EAAAA,EAAAA,UAAS,OAG7B,EAACC,EAAgB,EAACC,IAAsBF,EAAAA,EAAAA,WAAS,IAEvDG,EAAAA,EAAAA,YAAU,KACJL,IACkC,IAAhChD,EAAOsD,QAAQC,aACjBP,EAAMQ,SAENR,EAAMS,SAEV,GACC,CAAC5C,EAAS6C,YAEbL,EAAAA,EAAAA,YAAU,KAER,GADAD,GAAmB,GACL,MAAVpD,IAAmB4C,EAAc,CAGnCG,EAAU3D,OAAOuE,SACjB,MAAMC,EAAaC,IAEnB,MAAO,KACLD,EAAW5E,SAAS,CAExB,IACC,CAACgB,EAAQ4C,IAEZ,MAAMkB,GAAYC,EAAAA,EAAAA,IAAezD,GAAOA,GAAM0D,EAAAA,EAAAA,IAAW1D,GAEnDuD,EAAmBA,KACvB,MAAMD,EAAaK,EAAe,CAEhCjE,OAAQA,EAAOsD,QAEfxE,aAAaiF,EAAAA,EAAAA,IAAezD,GAAO,IAAI4D,IAAI5D,GAAKxC,OAASsB,OAAOtB,OAEhEzC,QAAS,CACP8I,UAAUC,GAAe,IAADC,OAAN,IAARD,IAAAA,EAAW,GACP,QAAZC,EAAIvD,gBAAQ,IAAAuD,GAARA,EAAUC,mBACZxD,SAASwD,iBAAiBH,UAAYC,EAE1C,EACAG,SAAU,IAADC,EAAAC,EACP,OAAa,QAAbD,EAAOpF,cAAM,IAAAoF,GAAU,QAAVC,EAAND,EAAQ3D,gBAAQ,IAAA4D,OAAV,EAANA,EAAkBC,IAC3B,EACAC,OAAOC,GAAM,IAADC,EACA,QAAVA,EAAIzF,cAAM,IAAAyF,GAANA,EAAQhE,WACVzB,OAAOyB,SAAW+D,EAEtB,EACAE,UAAUrC,GACRzC,EAAOsD,QAAQyB,MAAMtC,OAASA,CAChC,EACAuC,oBAAqB,IAADC,EAClB,OAAW,QAAXA,EAAIlC,SAAO,IAAAkC,GAAPA,EAASC,iBACJnC,EAAQoC,iBAGV,IACT,EACAC,gBAAiB,IAADC,EACd,OAAW,QAAXA,EAAItC,SAAO,IAAAsC,GAAPA,EAASH,iBACJnC,EAAQuC,aAGV,IACT,EACAC,SACMxC,IAAYA,EAAQmC,kBACtBnC,EAAQwC,QAEZ,EACAC,UACMzC,GAAWA,EAAQmC,kBACrBnC,EAAQyC,SAEZ,EACAC,iBACE,OAAI1C,EACKA,EAAQ2C,YAAYC,UAEpB,IAEX,KAgBJ,OAZA/B,EAAWlC,QAAQ/B,MAAMqD,IACa,IAAhChD,EAAOsD,QAAQC,aACjBP,EAAMQ,SAENR,EAAMS,SAERR,EAASD,EAAM,IAIjBI,GAAmB,GAEZQ,CAAU,EAGnB,OACEgC,EAAAA,EAAAA,IAAAC,EAAAA,QAAAA,SAAA,MACED,EAAAA,EAAAA,IAAA,UACEE,MAAM,eACNC,IAAK/F,EACLM,IAAK6C,EAAkBW,EAAY,GACnCkC,KAAKA,EAAAA,EAAAA,IAAG,wBAEIvD,EAAM,kCAKpBmD,EAAAA,EAAAA,IAACK,EAAAA,EAAM,MACN,C","sources":["webpack://commerce-pwa-studio/./node_modules/penpal/lib/enums.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/parent/getOriginFromSrc.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/errorSerialization.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/generateId.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/methodSerialization.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/connectCallSender.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/parent/handleAckMessageFactory.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/connectCallReceiver.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/parent/monitorIframeRemoval.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/parent/connectToChild.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/createLogger.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/createDestructor.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/parent/handleSynMessageFactory.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/startConnectionTimeout.js","webpack://commerce-pwa-studio/./node_modules/penpal/lib/child/connectToParent.js","webpack://commerce-pwa-studio/./node_modules/@adobe/gatsby-theme-aio/src/components/Frame/index.js"],"sourcesContent":["export var MessageType;\n(function (MessageType) {\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Reply\"] = \"reply\";\n    MessageType[\"Syn\"] = \"syn\";\n    MessageType[\"SynAck\"] = \"synAck\";\n    MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n    Resolution[\"Fulfilled\"] = \"fulfilled\";\n    Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n    ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n    ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n    NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n    NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));\n","const DEFAULT_PORT_BY_PROTOCOL = {\n    'http:': '80',\n    'https:': '443',\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src) => {\n    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n        // The origin of the child document is an opaque origin and its\n        // serialization is \"null\"\n        // https://html.spec.whatwg.org/multipage/origin.html#origin\n        return 'null';\n    }\n    // Note that if src is undefined, then srcdoc is being used instead of src\n    // and we can follow this same logic below to get the origin of the parent,\n    // which is the origin that we will need to use.\n    const location = document.location;\n    const regexResult = URL_REGEX.exec(src);\n    let protocol;\n    let hostname;\n    let port;\n    if (regexResult) {\n        // It's an absolute URL. Use the parsed info.\n        // regexResult[1] will be undefined if the URL starts with //\n        protocol = regexResult[1] ? regexResult[1] : location.protocol;\n        hostname = regexResult[2];\n        port = regexResult[4];\n    }\n    else {\n        // It's a relative path. Use the current location's info.\n        protocol = location.protocol;\n        hostname = location.hostname;\n        port = location.port;\n    }\n    // If the port is the default for the protocol, we don't want to add it to the origin string\n    // or it won't match the message's event.origin.\n    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';\n    return `${protocol}//${hostname}${portSuffix}`;\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (originForReceiving !== '*' &&\n                        event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n","import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default (serializedMethods, childOrigin, originForSending, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    let destroyCallReceiver;\n    let receiverMethodNames;\n    // We resolve the promise with the call sender. If the child reconnects\n    // (for example, after refreshing or navigating to another page that\n    // uses Penpal, we'll update the call sender with methods that match the\n    // latest provided by the child.\n    const callSender = {};\n    return (event) => {\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received ACK');\n        const info = {\n            localName: 'Parent',\n            local: window,\n            remote: event.source,\n            originForSending: originForSending,\n            originForReceiving: childOrigin,\n        };\n        // If the child reconnected, we need to destroy the prior call receiver\n        // before setting up a new one.\n        if (destroyCallReceiver) {\n            destroyCallReceiver();\n        }\n        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        // If the child reconnected, we need to remove the methods from the\n        // previous call receiver off the sender.\n        if (receiverMethodNames) {\n            receiverMethodNames.forEach((receiverMethodName) => {\n                delete callSender[receiverMethodName];\n            });\n        }\n        receiverMethodNames = event.data.methodNames;\n        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default (iframe, destructor) => {\n    const { destroy, onDestroy } = destructor;\n    const checkIframeInDocIntervalId = setInterval(() => {\n        if (!iframe.isConnected) {\n            clearInterval(checkIframeInDocIntervalId);\n            destroy();\n        }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n        clearInterval(checkIframeInDocIntervalId);\n    });\n};\n","import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options) => {\n    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Parent', log);\n    const { onDestroy, destroy } = destructor;\n    if (!childOrigin) {\n        validateIframeHasSrcOrSrcDoc(iframe);\n        childOrigin = getOriginFromSrc(iframe.src);\n    }\n    // If event.origin is \"null\", the remote protocol is file: or data: and we\n    // must post messages with \"*\" as targetOrigin when sending messages.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n    const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);\n    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            if (event.source !== iframe.contentWindow || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.Syn) {\n                handleSynMessage(event);\n                return;\n            }\n            if (event.data.penpal === MessageType.Ack) {\n                const callSender = handleAckMessage(event);\n                if (callSender) {\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n                return;\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        log('Parent: Awaiting handshake');\n        monitorIframeRemoval(iframe, destructor);\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","import { ErrorCode } from '../enums';\nexport default (iframe) => {\n    if (!iframe.src && !iframe.srcdoc) {\n        const error = new Error('Iframe must have src or srcdoc property defined.');\n        error.code = ErrorCode.NoIframeSrc;\n        throw error;\n    }\n};\n","import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default (log, serializedMethods, childOrigin, originForSending) => {\n    return (event) => {\n        // Under specific timing circumstances, we can receive an event\n        // whose source is null. This seems to happen when the child iframe is\n        // removed from the DOM about the same time it has sent the SYN event.\n        // https://github.com/Aaronius/penpal/issues/85\n        if (!event.source) {\n            return;\n        }\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n        const synAckMessage = {\n            penpal: MessageType.SynAck,\n            methodNames: Object.keys(serializedMethods),\n        };\n        event.source.postMessage(synAckMessage, originForSending);\n    };\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","import createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport { MessageType, NativeEventType } from '../enums';\nimport handleSynAckMessageFactory from './handleSynAckMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport startConnectionTimeout from '../startConnectionTimeout';\nconst areGlobalsAccessible = () => {\n    try {\n        clearTimeout();\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n};\n/**\n * Attempts to establish communication with the parent window.\n */\nexport default (options = {}) => {\n    const { parentOrigin = '*', methods = {}, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Child', log);\n    const { destroy, onDestroy } = destructor;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynAckMessage = handleSynAckMessageFactory(parentOrigin, serializedMethods, destructor, log);\n    const sendSynMessage = () => {\n        log('Child: Handshake - Sending SYN');\n        const synMessage = { penpal: MessageType.Syn };\n        const parentOriginForSyn = parentOrigin instanceof RegExp ? '*' : parentOrigin;\n        window.parent.postMessage(synMessage, parentOriginForSyn);\n    };\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            // Under niche scenarios, we get into this function after\n            // the iframe has been removed from the DOM. In Edge, this\n            // results in \"Object expected\" errors being thrown when we\n            // try to access properties on window (global properties).\n            // For this reason, we try to access a global up front (clearTimeout)\n            // and if it fails we can assume the iframe has been removed\n            // and we ignore the message event.\n            if (!areGlobalsAccessible()) {\n                return;\n            }\n            if (event.source !== parent || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.SynAck) {\n                const callSender = handleSynAckMessage(event);\n                if (callSender) {\n                    window.removeEventListener(NativeEventType.Message, handleMessage);\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        sendSynMessage();\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React, { useContext, useRef, useEffect, useState } from 'react';\nimport { withPrefix } from 'gatsby';\nimport { css } from '@emotion/react';\nimport { connectToChild } from 'penpal';\nimport { Footer } from '../Footer';\nimport PropTypes from 'prop-types';\nimport Context from '../Context';\nimport { isExternalLink } from '../../utils';\n\nconst Frame = ({ src, height = 'calc(100vh - var(--spectrum-global-dimension-size-800))', location }) => {\n  const iframe = useRef(null);\n  // some strangeness with ims not being set within context???\n  const { ims, isLoadingIms } = useContext(Context);\n  let imsHack;\n  const [child, setChild] = useState(null);\n\n  // ensures connectToChild is called before the child calls connectToParent\n  const [connectionReady, setConnectionReady] = useState(false);\n\n  useEffect(() => {\n    if (child) {\n      if (iframe.current.clientHeight === 0) {\n        child.onHide();\n      } else {\n        child.onShow();\n      }\n    }\n  }, [location.pathname]);\n\n  useEffect(() => {\n    setConnectionReady(false);\n    if (iframe != null && !isLoadingIms) {\n\n      // TODO: figure out why ims from context is not being updated so have to use a hacky solution like this\n      imsHack = window.adobeIMS;\n      const connection = createConnection();\n\n      return () => {\n        connection.destroy();\n      };\n    }\n  }, [iframe, isLoadingIms]);\n\n  const iframeSrc = isExternalLink(src) ? src : withPrefix(src);\n\n  const createConnection = () => {\n    const connection = connectToChild({\n      // The iframe to which a connection should be made\n      iframe: iframe.current,\n      // Manually set origin as auto-detection may fail, as the src of the iframe is set later\n      childOrigin: isExternalLink(src) ? new URL(src).origin : window.origin,\n      // Methods the parent is exposing to the child\n      methods: {\n        scrollTop(position = 0) {\n          if (document?.scrollingElement) {\n            document.scrollingElement.scrollTop = position;\n          }\n        },\n        getURL() {\n          return window?.location?.href;\n        },\n        setURL(url) {\n          if (window?.location) {\n            window.location = url;\n          }\n        },\n        setHeight(height) {\n          iframe.current.style.height = height;\n        },\n        getIMSAccessToken() {\n          if (imsHack?.isSignedInUser()) {\n            return imsHack.getAccessToken();\n          }\n\n          return null;\n        },\n        getIMSProfile() {\n          if (imsHack?.isSignedInUser()) {\n            return imsHack.getProfile();\n          }\n\n          return null;\n        },\n        signIn() {\n          if (imsHack && !imsHack.isSignedInUser()) {\n            imsHack.signIn();\n          }\n        },\n        signOut() {\n          if (imsHack && imsHack.isSignedInUser()) {\n            imsHack.signOut();\n          }\n        },\n        getIMSClientId() {\n          if (imsHack) {\n            return imsHack.adobeIdData.client_id;\n          } else {\n            return null;\n          }\n        }\n      }\n    });\n\n    connection.promise.then((child) => {\n      if (iframe.current.clientHeight === 0) {\n        child.onHide();\n      } else {\n        child.onShow();\n      }\n      setChild(child);\n    });\n\n    // Notify that the connection is ready and the iframe src may be set\n    setConnectionReady(true);\n\n    return connection;\n  };\n\n  return (\n    <>\n      <iframe\n        title=\"Main content\"\n        ref={iframe}\n        src={connectionReady ? iframeSrc : ''}\n        css={css`\n          display: block;\n          height: ${height};\n          width: 100%;\n          border: none;\n        `}\n      />\n      <Footer />\n    </>\n  );\n};\n\nFrame.propTypes = {\n  src: PropTypes.string,\n  height: PropTypes.string,\n  location: PropTypes.object\n};\n\nexport default Frame;\n"],"names":["Resolution","ErrorCode","NativeErrorName","MessageType","NativeEventType","DEFAULT_PORT_BY_PROTOCOL","URL_REGEX","opaqueOriginSchemes","serializeError","name","message","stack","id","keyPathToSegments","keyPath","split","setAtKeyPath","subject","value","segments","reduce","prevSubject","key","idx","length","methods","prefix","flattenedMethods","Object","keys","forEach","push","join","segmentsToKeyPath","createKeyPath","assign","callSender","info","methodKeyPaths","destroyConnection","log","localName","local","remote","originForSending","originForReceiving","destroyed","createMethodProxy","methodName","args","iframeRemoved","closed","e","error","Error","code","ConnectionDestroyed","Promise","resolve","reject","generateId","handleMessageEvent","event","source","data","penpal","origin","replyMessage","removeEventListener","returnValue","returnValueIsError","obj","deserializedError","deserializeError","resolution","Fulfilled","addEventListener","callMessage","postMessage","api","deserializeMethods","serializedMethods","childOrigin","destructor","destroy","onDestroy","destroyCallReceiver","receiverMethodNames","window","createPromiseHandler","Rejected","err","DataCloneError","errorReplyMessage","apply","then","receiverMethodName","methodNames","destroyCallSender","options","iframe","timeout","debug","console","callbacks","callback","src","srcdoc","NoIframeSrc","validateIframeHasSrcOrSrcDoc","find","scheme","startsWith","location","document","regexResult","exec","protocol","hostname","port","getOriginFromSrc","handleSynMessage","synAckMessage","handleSynMessageFactory","handleAckMessage","handleAckMessageFactory","promise","stopConnectionTimeout","timeoutId","undefined","setTimeout","ConnectionTimeout","clearTimeout","handleMessage","contentWindow","checkIframeInDocIntervalId","setInterval","isConnected","clearInterval","monitorIframeRemoval","_ref","height","useRef","ims","isLoadingIms","useContext","Context","imsHack","child","setChild","useState","connectionReady","setConnectionReady","useEffect","current","clientHeight","onHide","onShow","pathname","adobeIMS","connection","createConnection","iframeSrc","isExternalLink","withPrefix","connectToChild","URL","scrollTop","position","_document","scrollingElement","getURL","_window","_window$location","href","setURL","url","_window2","setHeight","style","getIMSAccessToken","_imsHack","isSignedInUser","getAccessToken","getIMSProfile","_imsHack2","getProfile","signIn","signOut","getIMSClientId","adobeIdData","client_id","___EmotionJSX","React","title","ref","css","Footer"],"sourceRoot":""}